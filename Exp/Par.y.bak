-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Exp.Par where
import qualified Exp.Abs
import Exp.Lex
}

%name pModule Module
%name pExp Exp
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  '-' { PT _ (TS _ 5) }
  '->' { PT _ (TS _ 6) }
  '.1' { PT _ (TS _ 7) }
  '.2' { PT _ (TS _ 8) }
  '0' { PT _ (TS _ 9) }
  '1' { PT _ (TS _ 10) }
  ':' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '@' { PT _ (TS _ 16) }
  'Glue' { PT _ (TS _ 17) }
  'Id' { PT _ (TS _ 18) }
  'PathP' { PT _ (TS _ 19) }
  'U' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  '\\' { PT _ (TS _ 22) }
  '\\/' { PT _ (TS _ 23) }
  ']' { PT _ (TS _ 24) }
  'comp' { PT _ (TS _ 25) }
  'data' { PT _ (TS _ 26) }
  'fill' { PT _ (TS _ 27) }
  'glue' { PT _ (TS _ 28) }
  'hComp' { PT _ (TS _ 29) }
  'hdata' { PT _ (TS _ 30) }
  'idC' { PT _ (TS _ 31) }
  'idJ' { PT _ (TS _ 32) }
  'import' { PT _ (TS _ 33) }
  'in' { PT _ (TS _ 34) }
  'let' { PT _ (TS _ 35) }
  'module' { PT _ (TS _ 36) }
  'mutual' { PT _ (TS _ 37) }
  'opaque' { PT _ (TS _ 38) }
  'split' { PT _ (TS _ 39) }
  'split@' { PT _ (TS _ 40) }
  'transparent' { PT _ (TS _ 41) }
  'transparent_all' { PT _ (TS _ 42) }
  'transport' { PT _ (TS _ 43) }
  'undefined' { PT _ (TS _ 44) }
  'unglue' { PT _ (TS _ 45) }
  'where' { PT _ (TS _ 46) }
  'with' { PT _ (TS _ 47) }
  '{' { PT _ (TS _ 48) }
  '|' { PT _ (TS _ 49) }
  '}' { PT _ (TS _ 50) }
  L_AIdent { PT _ (T_AIdent _) }
  L_CIdent { PT _ (T_CIdent $$) }
  L_HoleIdent { PT _ (T_HoleIdent _) }

%%

AIdent :: { Exp.Abs.AIdent}
AIdent  : L_AIdent { Exp.Abs.AIdent (mkPosToken $1) }

CIdent :: { Exp.Abs.CIdent}
CIdent  : L_CIdent { Exp.Abs.CIdent $1 }

HoleIdent :: { Exp.Abs.HoleIdent}
HoleIdent  : L_HoleIdent { Exp.Abs.HoleIdent (mkPosToken $1) }

Module :: { Exp.Abs.Module }
Module : 'module' AIdent 'where' '{' ListImp ListDecl '}' { Exp.Abs.Module $2 $5 $6 }

Imp :: { Exp.Abs.Imp }
Imp : 'import' AIdent { Exp.Abs.Import $2 }

ListImp :: { [Exp.Abs.Imp] }
ListImp : {- empty -} { [] }
        | Imp { (:[]) $1 }
        | Imp ';' ListImp { (:) $1 $3 }

Decl :: { Exp.Abs.Decl }
Decl : AIdent ListTele ':' Exp '=' ExpWhere { Exp.Abs.DeclDef $1 $2 $4 $6 }
     | 'data' AIdent ListTele '=' ListLabel { Exp.Abs.DeclData $2 $3 $5 }
     | 'hdata' AIdent ListTele '=' ListLabel { Exp.Abs.DeclHData $2 $3 $5 }
     | AIdent ListTele ':' Exp '=' 'split' '{' ListBranch '}' { Exp.Abs.DeclSplit $1 $2 $4 $8 }
     | AIdent ListTele ':' Exp '=' 'undefined' { Exp.Abs.DeclUndef $1 $2 $4 }
     | 'mutual' '{' ListDecl '}' { Exp.Abs.DeclMutual $3 }
     | 'opaque' AIdent { Exp.Abs.DeclOpaque $2 }
     | 'transparent' AIdent { Exp.Abs.DeclTransparent $2 }
     | 'transparent_all' { Exp.Abs.DeclTransparentAll }

ListDecl :: { [Exp.Abs.Decl] }
ListDecl : {- empty -} { [] }
         | Decl { (:[]) $1 }
         | Decl ';' ListDecl { (:) $1 $3 }

ExpWhere :: { Exp.Abs.ExpWhere }
ExpWhere : Exp 'where' '{' ListDecl '}' { Exp.Abs.Where $1 $4 }
         | Exp { Exp.Abs.NoWhere $1 }

Exp :: { Exp.Abs.Exp }
Exp : 'let' '{' ListDecl '}' 'in' Exp { Exp.Abs.Let $3 $6 }
    | '\\' ListPTele '->' Exp { Exp.Abs.Lam $2 $4 }
    | '<' ListAIdent '>' Exp { Exp.Abs.PLam $2 $4 }
    | 'split@' Exp 'with' '{' ListBranch '}' { Exp.Abs.Split $2 $5 }
    | Exp1 { $1 }

Exp1 :: { Exp.Abs.Exp }
Exp1 : Exp2 '->' Exp1 { Exp.Abs.Fun $1 $3 }
     | ListPTele '->' Exp1 { Exp.Abs.Pi $1 $3 }
     | ListPTele '*' Exp1 { Exp.Abs.Sigma $1 $3 }
     | Exp2 { $1 }

Exp2 :: { Exp.Abs.Exp }
Exp2 : Exp2 '@' Formula { Exp.Abs.AppFormula $1 $3 }
     | Exp2 Exp3 { Exp.Abs.App $1 $2 }
     | Exp3 { $1 }

Exp3 :: { Exp.Abs.Exp }
Exp3 : 'PathP' Exp4 Exp4 Exp4 { Exp.Abs.PathP $2 $3 $4 }
     | 'comp' Exp4 Exp4 System { Exp.Abs.Comp $2 $3 $4 }
     | 'hComp' Exp4 Exp4 System { Exp.Abs.HComp $2 $3 $4 }
     | 'transport' Exp4 Exp4 { Exp.Abs.Trans $2 $3 }
     | 'fill' Exp4 Exp4 System { Exp.Abs.Fill $2 $3 $4 }
     | 'Glue' Exp4 System { Exp.Abs.Glue $2 $3 }
     | 'glue' Exp4 System { Exp.Abs.GlueElem $2 $3 }
     | 'unglue' Exp4 System { Exp.Abs.UnGlueElem $2 $3 }
     | 'Id' Exp4 Exp4 Exp3 { Exp.Abs.Id $2 $3 $4 }
     | 'idC' Exp4 System { Exp.Abs.IdPair $2 $3 }
     | 'idJ' Exp4 Exp4 Exp4 Exp4 Exp4 Exp4 { Exp.Abs.IdJ $2 $3 $4 $5 $6 $7 }
     | Exp4 { $1 }

Exp4 :: { Exp.Abs.Exp }
Exp4 : Exp4 '.1' { Exp.Abs.Fst $1 }
     | Exp4 '.2' { Exp.Abs.Snd $1 }
     | Exp5 { $1 }

Exp5 :: { Exp.Abs.Exp }
Exp5 : '(' Exp ',' ListExp ')' { Exp.Abs.Pair $2 $4 }
     | AIdent { Exp.Abs.Var $1 }
     | AIdent '{' Exp '}' { Exp.Abs.PCon $1 $3 }
     | 'U' { Exp.Abs.U }
     | HoleIdent { Exp.Abs.Hole $1 }
     | '(' Exp ')' { $2 }

ListExp :: { [Exp.Abs.Exp] }
ListExp : Exp { (:[]) $1 } | Exp ',' ListExp { (:) $1 $3 }

Dir :: { Exp.Abs.Dir }
Dir : '0' { Exp.Abs.Dir0 } | '1' { Exp.Abs.Dir1 }

System :: { Exp.Abs.System }
System : '[' ListSide ']' { Exp.Abs.System $2 }

Face :: { Exp.Abs.Face }
Face : '(' AIdent '=' Dir ')' { Exp.Abs.Face $2 $4 }

ListFace :: { [Exp.Abs.Face] }
ListFace : {- empty -} { [] } | Face ListFace { (:) $1 $2 }

Side :: { Exp.Abs.Side }
Side : ListFace '->' Exp { Exp.Abs.Side $1 $3 }

ListSide :: { [Exp.Abs.Side] }
ListSide : {- empty -} { [] }
         | Side { (:[]) $1 }
         | Side ',' ListSide { (:) $1 $3 }

Formula :: { Exp.Abs.Formula }
Formula : Formula '\\/' Formula1 { Exp.Abs.Disj $1 $3 }
        | Formula1 { $1 }

Formula1 :: { Exp.Abs.Formula }
Formula1 : Formula1 CIdent Formula2 { Exp.Abs.Conj $1 $2 $3 }
         | Formula2 { $1 }

Formula2 :: { Exp.Abs.Formula }
Formula2 : '-' Formula2 { Exp.Abs.Neg $2 }
         | AIdent { Exp.Abs.Atom $1 }
         | Dir { Exp.Abs.Dir $1 }
         | '(' Formula ')' { $2 }

Branch :: { Exp.Abs.Branch }
Branch : AIdent ListAIdent '->' ExpWhere { Exp.Abs.OBranch $1 $2 $4 }
       | AIdent ListAIdent '@' ListAIdent '->' ExpWhere { Exp.Abs.PBranch $1 $2 $4 $6 }

ListBranch :: { [Exp.Abs.Branch] }
ListBranch : {- empty -} { [] }
           | Branch { (:[]) $1 }
           | Branch ';' ListBranch { (:) $1 $3 }

Label :: { Exp.Abs.Label }
Label : AIdent ListTele { Exp.Abs.OLabel $1 $2 }
      | AIdent ListTele '<' ListAIdent '>' System { Exp.Abs.PLabel $1 $2 $4 $6 }

ListLabel :: { [Exp.Abs.Label] }
ListLabel : {- empty -} { [] }
          | Label { (:[]) $1 }
          | Label '|' ListLabel { (:) $1 $3 }

Tele :: { Exp.Abs.Tele }
Tele : '(' AIdent ListAIdent ':' Exp ')' { Exp.Abs.Tele $2 $3 $5 }

ListTele :: { [Exp.Abs.Tele] }
ListTele : {- empty -} { [] } | Tele ListTele { (:) $1 $2 }

PTele :: { Exp.Abs.PTele }
PTele : '(' Exp ':' Exp ')' { Exp.Abs.PTele $2 $4 }

ListPTele :: { [Exp.Abs.PTele] }
ListPTele : PTele { (:[]) $1 } | PTele ListPTele { (:) $1 $2 }

ListAIdent :: { [Exp.Abs.AIdent] }
ListAIdent : {- empty -} { [] } | AIdent ListAIdent { (:) $1 $2 }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

